import UIComponent, { mediaQuery } from "../../../base";
import {
    addWindowResizeListener,
    removeWindowResizeListener
} from "../../../helpers/dom/dom";
import { CellGrid } from "../../atomic/grid";
import classNames from "classnames";
import Container from "../../atomic/container";

const isExtraSmallScreen = () => mediaQuery.atMost("XS");
const isSmallScreen = () => mediaQuery.atMost("SM");
const isLargeScreen = () => mediaQuery.atLeast("LG");
const RESIZE_TIMEOUT = 300;
const DEFAULT_XS_COLUMNCOUNT = 1;
const DEFAULT_SM_COLUMNCOUNT = 2;
const DEFAULT_MD_COLUMNCOUNT = 3;
const DEFAULT_LG_COLUMNCOUNT = 4;

/**
 * FLOWDIRECTION
 * @type {{HORIZONTAL: string, VERTICAL: string}}
 */
const FLOWDIRECTION = {
    HORIZONTAL: "horizontal",
    VERTICAL: "vertical"
};

/**
 * Depending on the flow direction, uses the current content index at [i, j] to
 * populate the content.
 * @param {Number} rowIndex - Row index.
 * @param {Number} columnIndex - Column index.
 * @param {String} flowDirection - Flow direction.
 * @param {Number} rowCount - Number of rows.
 * @param {Number} columnCount - Number of columns.
 * @returns {Number} The matrix index converted to an index in the content array.
 */
const mapMatrixToIndex = (rowIndex, columnIndex, flowDirection, rowCount, columnCount) =>
    // When flowDirection is horizontal, data will return as
    // 1 2 3
    // 4 5 6
    // When flowDirection is vertical, data will return as
    // 1 3 5
    // 2 5 6
    flowDirection === FLOWDIRECTION.HORIZONTAL ? (rowIndex * columnCount) + columnIndex : (columnIndex * rowCount) + rowIndex;

/**
 * Returns the number of columns based on the screen resolution
 * @returns {number} Returns the column count.
 */
const calculateColumnCount = () => {
    if (isExtraSmallScreen()) {
        return DEFAULT_XS_COLUMNCOUNT;
    }
    else if (isSmallScreen()) {
        return DEFAULT_SM_COLUMNCOUNT;
    }
    else if (isLargeScreen()) {
        return DEFAULT_LG_COLUMNCOUNT;
    }
    return DEFAULT_MD_COLUMNCOUNT;
};

/**
 * Return the content for the CellGrid.
 * @param {Number} currentLoopCount - Row index.
 * @param {Number} totalRowCount - Total Number of rows.
 * @param {Number} rowCount - Number of rows.
 * @param {Number} columnCount - Number of columns.
 * @param {String} flowDirection - Flow direction.
 * @param {Number} content - Child Content passed as Prop.
 * @returns {Array<UIComponent>} The Array<UIComponent> to be displayed in CellGrid.
 */
const getContentForCellGrid = (currentLoopCount, totalRowCount, rowCount, columnCount, flowDirection, content) =>
    [ ...Array(rowCount) ].reduce((accumulator, _, rowIndex) =>
        accumulator.concat(Array.from({ length: 1 }, (__, columnIndex) =>
            content[mapMatrixToIndex(rowIndex, currentLoopCount, flowDirection, totalRowCount, columnCount)]
        ))
        , []
    );

/**
 * Return the rowCount
 * @param {String} flowDirection - Flow direction.
 * @param {Number} reminder - Reminder.
 * @param {Number} columnIndex - Column Index.
 * @param {Number} totalRowCount - Total Number of rows.
 * @param {Number} rowCount - Number of rows.
 * @param {Number} columnCount - Number of columns.
 * @param {Number} contentLength - Length of Content.
 * @returns {Number} rowCount.
 */
const calculateRowCount = (flowDirection, reminder, columnIndex, totalRowCount, rowCount, columnCount, contentLength) => {
    if (flowDirection === FLOWDIRECTION.VERTICAL) {
        if (columnIndex < reminder || !reminder) {
            return totalRowCount;
        }
        else {
            return columnIndex === columnCount - 1 ? contentLength - (totalRowCount * columnIndex) : totalRowCount;
        }
    }
    else {
        return reminder > columnIndex ? totalRowCount : rowCount;
    }
};

/**
 * Creates the dynamic Container control embedded with CellGrid control based on number of Columns to be displayed.
 * @param {Number} content - content passed as Prop.
 * @param {String} flowDirection - Flow direction passed as Prop.
 * @param {Boolean} showBorder - showBorder passed as Prop.
 * @returns {Array<Container>} The Array<Container> to be displayed.
 */
const createContent = ({ content, flowDirection, showBorder }) => {
    let columnCount = calculateColumnCount() > content.length ? content.length : calculateColumnCount();
    let rowCount = Math.floor(content.length / columnCount);
    const totalRowCount = Math.ceil(content.length / columnCount);

    if (flowDirection === FLOWDIRECTION.VERTICAL) {
        columnCount = Math.ceil(content.length / totalRowCount) < columnCount ? Math.ceil(content.length / totalRowCount) : columnCount;
        rowCount = Math.floor(content.length / columnCount);
    }
    const reminder = content.length % columnCount;

    return Array.from({ length: columnCount }, (_, columnIndex) =>
        new Container({
            classNames: classNames(
                "mpageui-u-flexgrid-col",
                "mpageui-u-margin-absolute-very-tight",
                "mpageui-CellGridContainer",
                "mpageui-CellGridContainer-Width",
                {
                    "mpageui-CellGridContainer-Cell": !showBorder
                }),
            wrapChildren: true
        },
        [
            new CellGrid({
                content: getContentForCellGrid(
                    columnIndex,
                    totalRowCount,
                    calculateRowCount(flowDirection, reminder, columnIndex, totalRowCount, rowCount, columnCount, content.length),
                    columnCount,
                    flowDirection,
                    content
                )
            })
        ])
    );
};


/**
 * The ColumnLayout class for laying out content in a grid-like fashion dynamically.
 * @class ColumnLayout
 */
export default class ColumnLayout extends UIComponent {

    /**
     * @inheritDoc
     */
    constructor(props, children) {
        super(props, children);
        this._windowResizeHandler = this._windowResizeHandler.bind(this);
    }

    /**
     * @inheritDoc
     */
    initialProps() {
        return {
            flowDirection: FLOWDIRECTION.HORIZONTAL,
            content: [],
            showBorder: false
        };
    }

    /**
     * @inheritDoc
     */
    dependentPropChangeHandlers() {
        return [
            [ "content", "flowDirection", "showBorder",
                (content, flowDirection, showBorder) => {
                    this.replaceAllChildren(createContent({ content, flowDirection, showBorder }));
                }
            ]
        ];
    }

    /**
     * @inheritDoc
     */
    createChildren({ props }) {
        return createContent(props);
    }

    /**
     * @inheritDoc
     */
    view(el, props, children, mappedChildren) {
        return el(
            "div", {
                oncreate: () => addWindowResizeListener(this._windowResizeHandler),
                onremove: () => removeWindowResizeListener(this._windowResizeHandler),
                class: "mpageui-ColumnLayout mpageui-u-flexgrid-row"
            },
            this.renderChildren()
        );
    }

    /**
     * Handles window resizing
     * @returns {undefined}
     */
    _windowResizeHandler() {
        setTimeout(() => {
            this.replaceAllChildren(createContent(this.getProps())).update();
        }, RESIZE_TIMEOUT);
    }
}

ColumnLayout.FLOWDIRECTION = FLOWDIRECTION;
